networks:
  net01:
    driver: bridge

services:

#----------------------------------------------------------------------------------------------
  # mysql环境
  # https://github.com/bitnami/containers/tree/main/bitnami/mysql#how-to-use-this-image
  # todo sudo rm -rf mysql ; sudo mkdir -p mysql/data mysql/conf  && sudo chown -R 1001:1001 mysql &&  sudo docker pull registry.cn-guangzhou.aliyuncs.com/dbinggo-bitnami/mysql:8.0 && sudo docker tag registry.cn-guangzhou.aliyuncs.com/dbinggo-bitnami/mysql:8.0 bitnami/mysql:8.0
  mysql:
    image: bitnami/mysql:8.0  # sudo docker pull registry.cn-guangzhou.aliyuncs.com/dbinggo-bitnami/mysql:8.0 && sudo docker tag registry.cn-guangzhou.aliyuncs.com/dbinggo-bitnami/mysql:8.0 bitnami/mysql:8.0
    container_name: mysql-minify # 强制指定容器的名称为 mysql
    hostname: mysql # 设置容器内部的主机名为 mysql
    restart: unless-stopped
#    privileged: true # 特权模式
    ports:
      - "3306:3306"
    environment:
      TZ: Asia/Shanghai
      MYSQL_ROOT_PASSWORD: root
      MYSQL_DATABASE: minify
#    volumes:
#      - "./mysql/data:/bitnami/mysql/data" # sudo rm -rf mysql ; sudo mkdir mysql && sudo chown -R 1001:1001 mysql
#      - "./mysql/conf:/opt/bitnami/mysql/conf"
    networks:
      - net01
    healthcheck:
      test: [ 'CMD', '/opt/bitnami/scripts/mysql/healthcheck.sh' ]
      interval: 10s
      timeout: 5s
      retries: 6
  redis:
    image: "bitnami/redis:latest"
    container_name: redis-minify # 强制指定容器的名称为 mysql
    hostname: redis # 设置容器内部的主机名为 mysql
    restart: unless-stopped
    ports:
      - '6379:6379'
    environment:
      - ALLOW_EMPTY_PASSWORD=yes
    networks:
      - net01
  kafka:
    image: bitnami/kafka:3.9.0
    container_name: kafka-minify
    hostname: kafka
    restart: unless-stopped
    ports:
      - "9092:9092"    # 外部客户端 (如您的Go程序) 连接端口
      - "9093:9093"    # 控制器通信端口 (通常无需暴露给主机，但保留亦可)
    environment:
      # KRaft 模式配置
      - KAFKA_ENABLE_KRAFT=yes
      - KAFKA_CFG_PROCESS_ROLES=controller,broker
      - KAFKA_CFG_NODE_ID=1
      # 1.【关键修改】使用服务名'kafka'代替IP地址，这是Docker网络内部的通信方式
      - KAFKA_CFG_CONTROLLER_QUORUM_VOTERS=1@kafka:9093

      # 监听器配置
      # 2.【关键修改】定义了三个监听器：
      # EXTERNAL: 用于外部客户端（您的Go程序）连接
      # INTERNAL: 用于内部容器间（Kafka与Kafdrop）通信
      # CONTROLLER: 用于KRaft控制器通信
      - KAFKA_CFG_LISTENERS=EXTERNAL://:9092,INTERNAL://:29092,CONTROLLER://:9093

      # 3.【关键修改】对外公告的地址
      # EXTERNAL 公告为 localhost，供您的主机Go程序使用
      # INTERNAL 公告为 kafka服务名+内部端口，供Kafdrop使用
      - KAFKA_CFG_ADVERTISED_LISTENERS=EXTERNAL://localhost:9092,INTERNAL://kafka:29092

      # 安全协议映射（增加了EXTERNAL）
      - KAFKA_CFG_LISTENER_SECURITY_PROTOCOL_MAP=CONTROLLER:PLAINTEXT,INTERNAL:PLAINTEXT,EXTERNAL:PLAINTEXT

      # Broker间通信使用内部监听器
      - KAFKA_CFG_INTER_BROKER_LISTENER_NAME=INTERNAL
      - KAFKA_CFG_CONTROLLER_LISTENER_NAMES=CONTROLLER
    networks:
      - net01

  kafdrop:
    image: obsidiandynamics/kafdrop:latest
    container_name: kafdrop-minify
    hostname: kafdrop
    restart: unless-stopped
    ports:
      - "19000:9000"  # 将Kafdrop的UI端口映射到主机的19000端口
    environment:
      - KAFKA_BROKERCONNECT=kafka:29092 # Kafdrop 通过 Kafka 的内部监听器进行连接
    depends_on:
      - kafka
    networks:
      - net01